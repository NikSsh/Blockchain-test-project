package blockchain.model;

import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Facade that provides methods to interact with blockchain.
 * Also, responsible for maintaining and receiving incoming data(transactions)
 */
public class BlockchainFacade {
    private final ConcurrentLinkedQueue<SignedTransaction> dataQueue = new ConcurrentLinkedQueue<>();
    private final Blockchain blockchain;
    public int size() {
        return blockchain.getBlockchainSize();
    }

    public BlockchainFacade(Blockchain blockchain) {
        this.blockchain = blockchain;
    }

    /**
     @return String that contains all available transactions separated by a line break character
     */
    public synchronized String getData() {
        StringBuilder dataBuilder = new StringBuilder();
        while (!dataQueue.isEmpty()) {
            dataBuilder.append(dataQueue.poll()).append("\n");
        }

        return dataBuilder.toString();
    }

    /**
     * @param data String data that will be saved in block
     * @return Block object that is generated by blockchain generateNewBlock(data) method
     */
    public Block createBlock(String data) {
        return blockchain.generateNewBlock(data);
    }

    /**
     * @param newBlock instance of Block class that was generated and gonna be added to blockchain
     * @return boolean value that represents success of adding new block to blockchain
     */
    public boolean addBlock(Block newBlock) {
        return blockchain.addNewBlock(newBlock);
    }

    /**
     * @return map ledges of all clients with corresponding balance
     */
    public Map<String, Integer> getLedger() {
        return blockchain.getLedger();
    }

    /**
     * Checks whether the transaction valid, adds it to the dataQueue and blockchain ledger
     */
    public void offerTransaction(SignedTransaction transaction) {
        if (blockchain.isTransactionValid(transaction)) {
            dataQueue.offer(transaction);
            blockchain.addTransactionToLedger(transaction);
        } else {
            //log.warn("Invalid digital transaction <%s> received ".formatted(transaction.toString()));
        }
    }

    public boolean isDataQueueEmpty() {
        return dataQueue.isEmpty();
    }

    public void displayBlockchain() {
        blockchain.displayBlockchain();
    }

    public void displayLedger() {
        System.out.println("Ledger:");
        blockchain.getLedger().forEach((name, amount) -> System.out.println(name + " : " + amount + " VC"));
    }

    public void clear() {
        blockchain.clear();
    }
}
